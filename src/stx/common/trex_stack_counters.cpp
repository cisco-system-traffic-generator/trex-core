/*
  hhaim
  Cisco Systems, Inc.
*/

/*
  Copyright (c) 2016-2016 Cisco Systems, Inc.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

#include "trex_stack_counters.h"


static void create_sc(CGTblClmCounters  * clm,
                                std::string name,
                                std::string help,
                                uint64_t * c,
                                bool keep_zero,
                                bool error,
                                bool is_abs = false){
    CGSimpleBase *lp;
    lp = new CGSimpleRefCnt64(c);
    lp->set_name(name);
    lp->set_help(help);

    lp->set_dump_zero(keep_zero);
    if (error){
        lp->set_info_level(scERROR);
    }
    lp->set_abs(is_abs);
    clm->add_count(lp);
}

#define RX_S_ADD_CNT(f,sf,help)  { create_sc(&m_clm,#sf,help,&f,false,false); }
// for errors
#define RX_S_ADD_CNT_E(f,sf,help)  { create_sc(&m_clm,#sf,help,&f,false,true); }


bool CRxCounters::Create(){
    RX_S_ADD_CNT(m_gen_cnt[CNT_RX][CNT_PKT][CNT_UNICAST],"rx_unicast_pkts","rx unicast pkts");
    RX_S_ADD_CNT(m_gen_cnt[CNT_TX][CNT_PKT][CNT_UNICAST],"tx_unicast_pkts","tx unicast pkts");

    RX_S_ADD_CNT(m_gen_cnt[CNT_RX][CNT_PKT][CNT_MULTICAST],"rx_multicast_pkts","rx multicast pkts");
    RX_S_ADD_CNT(m_gen_cnt[CNT_TX][CNT_PKT][CNT_MULTICAST],"tx_multicast_pkts","tx multicast pkts");

    RX_S_ADD_CNT(m_gen_cnt[CNT_RX][CNT_PKT][CNT_BROADCAST],"rx_broadcast_pkts","rx broadcast pkts");
    RX_S_ADD_CNT(m_gen_cnt[CNT_TX][CNT_PKT][CNT_BROADCAST],"tx_broadcast_pkts","tx broadcast pkts");

    RX_S_ADD_CNT(m_gen_cnt[CNT_RX][CNT_BYTE][CNT_UNICAST],"rx_unicast_bytes","rx unicast bytes");
    RX_S_ADD_CNT(m_gen_cnt[CNT_TX][CNT_BYTE][CNT_UNICAST],"tx_unicast_bytes","tx unicast bytes");

    RX_S_ADD_CNT(m_gen_cnt[CNT_RX][CNT_BYTE][CNT_MULTICAST],"rx_multicast_bytes","rx multicast bytes");
    RX_S_ADD_CNT(m_gen_cnt[CNT_TX][CNT_BYTE][CNT_MULTICAST],"tx_multicast_bytes","tx multicast bytes");

    RX_S_ADD_CNT(m_gen_cnt[CNT_RX][CNT_BYTE][CNT_BROADCAST],"rx_broadcast_bytes","rx broadcast bytes");
    RX_S_ADD_CNT(m_gen_cnt[CNT_TX][CNT_BYTE][CNT_BROADCAST],"tx_broadcast_bytes","tx broadcast bytes");

    RX_S_ADD_CNT(m_rx_bcast_filtered, "rx_bcast_filtered", "rx broadcast pkts not tcp/udp");
    RX_S_ADD_CNT(m_rx_mcast_filtered, "rx_mcast_filtered", "rx multicast pkts not tcp/udp");

    RX_S_ADD_CNT_E(m_tx_err_small_pkt,"tx_err_small_pkt","tx small packet was generated by namespace");
    RX_S_ADD_CNT_E(m_tx_err_big_9k,"tx_err_big_9k","tx big packet >9K was generated by namespace");
    RX_S_ADD_CNT_E(m_rx_err_invalid_pkt,"rx_err_invalid_pkt","rx invalid packet");

    RX_S_ADD_CNT_E(m_tx_dropped_no_mbuf,"tx_dropped_no_mbuf","tx drop packets no mbuf");

    m_clm.set_free_objects_own(true);

    m_tbl.add(&m_clm);
    clear_counters();
    return (true);
}

void CRxCounters::Delete(){
}

void CRxCounters::dump(){
    m_tbl.dump_table(stdout,false,true);
}

void CRxCounters::clear_counters(){
    m_tx_err_small_pkt = 0;
    m_tx_err_big_9k = 0;
    m_tx_dropped_no_mbuf = 0;
    m_rx_err_invalid_pkt = 0;
    m_rx_bcast_filtered = 0;
    m_rx_mcast_filtered = 0;

    int i,j,k;
    for (i=0; i<CNT_RX_TX_SIZE; i++) {
        for (j=0; j<CNT_TYPE; j++) {
            for (k=0; k<CNT_UMB_TYPE; k++) {
                m_gen_cnt[i][j][k]=0;
            }
        }
    }
}


void CRxCounters::dump_meta(std::string name,
                   Json::Value & json){
    m_tbl.dump_meta(name,json);
}

void CRxCounters::dump_values(std::string name,
                     bool zeros,
                     Json::Value & obj){
    return (m_tbl.dump_values(name,zeros,obj));
}




